require 'tempfile'

module Acceptance; end
module Acceptance::Helpers; end

# Methods to support 'simp kv' testing.  Data is generated by the kv_test
# Puppet module.

module Acceptance::Helpers::KvTestData

  # @return the Base64-encoded value of the binary data provided by the
  # kv_test module
  def binary_base64
    'BQIAAABXAAIABFRFU1QABGhvc3QAFmZha2VfaG9zdDEuc29tZS5kb21haW4AAAABXXfabAEAEg'\
    'AgaDM0Qy9kh4YJ5F9e9Z0sB9HNY+ejsIUn8nTBbT5xsrYAAAABAAAARwACAARURVNUAARob3N0'\
    'ABZmYWtlX2hvc3QxLnNvbWUuZG9tYWluAAAAAV132mwBABEAEDZg19gW99qgG+DQYeyffFMAAAAB'
  end

  def brief_kv_list_results(global)
    prefix =  global ? 'global_' : ''
    {
      '/' => {
        'keys'           => [
            "#{prefix}boolean",
            "#{prefix}float",
            "#{prefix}integer",
            "#{prefix}string",
        ],
        'folders' => root_kv_folders(global)
      },
      "#{prefix}complex" => {
        'keys'           => [
          'array_integers',
          'array_strings',
          'binary',
          'hash'
        ],
        'folders' => []
      }
    }
  end

  def detailed_kv_list_results(id_prefix, global)
    prefix = global ? 'global_' : ''
    {
      '/' => {
        'keys'    => {
          "#{prefix}boolean" => {
              'value'    => true,
              'metadata' => { 'id' => "#{id_prefix} #{prefix}boolean" }
          },
          "#{prefix}float"   => {
            'value'    => 4.567,
            'metadata' => { 'id' => "#{id_prefix} #{prefix}float" }
          },
          "#{prefix}integer" => {
            'value'    => 123,
            'metadata' => { 'id' => "#{id_prefix} #{prefix}integer" }
          },
          "#{prefix}string"  => {
            'value'    => 'string1',
            'metadata' => { 'id' => "#{id_prefix} #{prefix}string" }
          }
        },
        'folders' => root_kv_folders(global)
      },
      "#{prefix}complex" => {
        'keys'    => {
          'array_integers' => {
            'value'    => [ 8, 9, 10 ],
            'metadata' => { 'id' => "#{id_prefix} #{prefix}complex/array_integers" }
          },
          'array_strings'  => {
            'value'    => [ 'string2', 'string3' ],
            'metadata' => { 'id' => "#{id_prefix} #{prefix}complex/array_strings" }
          },
          'binary'         => {
            'value'             => binary_base64,
            'metadata'          => { 'id' => "#{id_prefix} #{prefix}complex/binary" },
            'encoding'          => 'base64',
            'original_encoding' => 'ASCII-8BIT'
          },
          'hash'           => {
            'value'    => {
              'key1' => 'string4',
              'key2' => 11,
              'key3' => false,
              'key4' => { 'nkey1' => 'string5', 'nkey2' => true, 'nkey3' => 12 }
            },
            'metadata' => { 'id' => "#{id_prefix} #{prefix}complex/hash" }
          }
        },
        'folders' => []
      }
    }
  end

  def keys_info(folder, detailed_list)
    keys = {}
    prefix = (folder == '/') ? '' : "#{folder}/"
    detailed_list[folder]['keys'].each do |key,info|
      keys["#{prefix}#{key}"] = info
    end

    keys
  end

  # change the value and metadata for each key info in a list result
  def change_key_info(current_list)
    updated_list = Marshal.load(Marshal.dump(current_list))
    updated_list.each do |folder,folder_info|
      folder_info['keys'].each do |key,key_info|
        if key_info['value'].is_a?(Array) || key_info['value'].is_a?(String)
          key_info['value'] = key_info['value'] + key_info['value']
        end

        if key_info['value'].is_a?(TrueClass) || key_info['value'].is_a?(FalseClass)
          key_info['value'] = ! key_info['value']
        end

        if key_info['value'].is_a?(Hash)
          key_info['value']['new_key'] = 'new string elem'
        end

        if key_info['value'].is_a?(Numeric)
          key_info['value'] *= 10
        end

        key_info['metadata']['version'] = 2
      end
    end

    updated_list
  end

  def create_key_info(regular_keys, binary_keys, env, backend )
    keys = {}
    list = { }
    key_prefix = env.nil? ? 'global_' : ''
    location = env.nil? ? 'global' : env
    regular_keys.each do |key|
      key_path = "#{key_prefix}#{key}"
      key_dir = File.dirname(key_path)
      key_dir = '/' if key_dir == '.'
      unless list.key?(key_dir)
        list[key_dir] = { 'keys' => {}, 'folders' => []}
      end

      info = {
        'value'    => "#{key_path} value",
        'metadata' => { 'id' => "#{backend} #{location} #{key_path}" }
      }

      keys[key_path] = info
      list[key_dir]['keys'][File.basename(key_path)] = info
    end

    sub_list = { 'keys' => {}, 'folders' => [] }
    binary_keys.each do |key|
      key_path = "#{key_prefix}#{key}"
      key_dir = File.dirname(key_path)
      key_dir = '/' if key_dir == '.'
      unless list.key?(key_dir)
        list[key_dir] = { 'keys' => {}, 'folders' => []}
      end

      info = {
        'value'             => binary_base64,
        'encoding'          => 'base64',
        'original_encoding' => 'ASCII-8BIT',
        'metadata'          => {
          'id' => "#{backend} #{location} #{key_path}"
        }
      }

      keys[key_path] = info
      list[key_dir]['keys'][File.basename(key_path)] = info
    end

    [ keys, list ]
  end

  def root_kv_folders(global)
    if global
      return [ 'dev', 'global_complex', 'production' ]
    else
      return [ 'complex' ]
    end
  end

  def run_and_load_json(host, cmd, json_file)
    on(host, cmd)
    JSON.load( on(host, "cat #{json_file}").stdout )
  end

  def verify_files(host, keys, root_path)
    puppet_version = on(host, 'puppet --version').stdout

    keys.each do |key,info|
      file = File.join(root_path, key)
      if info.key?('encoding')
        if puppet_version[0] == '5'
          puts "Skipping '#{key}' value check: Puppet 5 'puppet apply' does "\
               'not handle Binary type'
        else
          puts "Verifying '#{key}' value"
          actual_binary_file = "#{file}.bin"
          expected_binary_file = "/root/#{File.basename(key)}.bin"
          Tempfile.open 'kv_test_data' do |tempfile|
            File.open(tempfile.path, 'w') do |file|
              file.write(Base64.strict_decode64(info['value']))
            end

            rsync_to(host, tempfile.path, expected_binary_file)
          end
          on(host, "diff #{expected_binary_file} #{actual_binary_file}")
        end

       puts "Verifying '#{key}' metadata"
        meta_file = "#{file}.meta"
        actual_meta = JSON.load( on(host, "cat #{meta_file}").stdout )
        expect( actual_meta ).to eq(info['metadata'])
      else
        puts "Verifying '#{key}' value and metadata"
        actual = JSON.load( on(host, "cat #{file}").stdout )
        expect( actual ).to eq(info)
      end
    end
  end

end
