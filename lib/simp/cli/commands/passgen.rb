require File.expand_path( '../../cli', File.dirname(__FILE__) )

module Simp::Cli::Commands; end
class Simp::Cli::Commands::Passgen < Simp::Cli
  require 'fileutils'

  DEFAULT_ENVIRONMENT = 'production'

  @operation = nil
  @environment = nil
  @password_dir = nil
  @names = Array.new
  @backup_passwords = nil
  @force_remove = false

  @opt_parser = OptionParser.new do |opts|
    opts.banner = "\n=== The SIMP Passgen Tool ===."
    opts.separator ''
    opts.separator 'The SIMP Passgen Tool is a simple password control utility. It allows the'
    opts.separator 'viewing, setting, and removal of passwords generated by passgen.'
    opts.separator ''
    opts.separator '  simp passgen [-e ENV|-d DIR] -l'
    opts.separator '  simp passgen [-e ENV|-d DIR] -n NAME1,...'
    opts.separator '  simp passgen [-e ENV|-d DIR] [--[no-]backup] -s NAME1,...'
    opts.separator '  simp passgen [-e ENV|-d DIR] [--force-remove] -r NAME1,...'
    opts.separator '  simp passgen -E'
    opts.separator ''
    opts.separator "OPTIONS:\n"

    opts.on('-e', '--env ENV',
            'Puppet environment to which the passgen operation will',
            "be applied. Defaults to '#{DEFAULT_ENVIRONMENT}'.",
            "Ignored when '-d' option is specified." ) do |env|
      @environment = env
    end

    opts.on('-E', '--list-env', 'List possible environments that may contain passwords.') do
      @operation = :show_environment_list
    end

    opts.on('-d', '--dir DIR',
            'Fully qualified path to a password store.',
            "Overrides an environment specified by the '-e' option.") do |dir|
      @password_dir = dir
    end

    opts.on('-l', '--list-name', 'List possible password names for the specified environment.') do
      @operation = :show_name_list
    end

    opts.on('-n', '--name NAME1[,NAME2,...]', Array,
            'Show password(s) for NAME1[,NAME2,...] in the',
            'specified environment.') do |names|
      @operation = :show_passwords
      @names = names
    end

    opts.on('-s', '--set NAME1[,NAME2,...]', Array,
            'Set password(s) for NAME1[,NAME2,...] in the',
            'specified environment.') do |names|
      @operation = :set_passwords
      @names = names
    end

    opts.on('-b', '--[no-]backup',
            'Back up passwords when generating new ones. If',
            'unspecified, user will be prompted for action',
            'to take.') do |backup|
      @backup_passwords = backup
    end

    opts.on('-r', '--remove NAME1[,NAME2,...]', Array,
            'Remove all passwords for NAME1[,NAME2,...] in the',
            'specified environment.') do |names|
      @operation = :remove_passwords
      @names = names
    end

    opts.on('-f', '--force-remove',
            'Remove passwords without prompting user to verify.',
            'If unspecified, user will be prompted to verify',
            'removal action.') do |force_remove|
      @force_remove = force_remove
    end

    opts.on('-h', '--help', 'Print this message.') do
      puts opts
      @help_requested = true
    end
  end

  def self.run(args = Array.new)
    raise OptionParser::ParseError.new('The SIMP Passgen Tool requires at least one option') if args.empty?
    super
    return if @help_requested

    @environment = (@environment.nil? ? DEFAULT_ENVIRONMENT : @environment)
    @password_dir = get_password_dir if @password_dir.nil?

    case @operation
    when :show_environment_list
      show_environment_list
    when :show_name_list
      show_name_list
    when :show_passwords
      show_passwords
    when :set_passwords
      set_passwords
    when :remove_passwords
      remove_passwords
    else
      raise OptionParser::ParseError.new("No password operation specified.\n" + @opt_parser.help)
    end
  end

  def self.get_names
    names = []
    begin
      Dir.chdir(@password_dir) do
        names = Dir.glob('*').select do |x|
          File.file?(x) && (x !~ /\..+$/)  # exclude salt and backup files
        end
      end
    rescue SystemCallError => err
      raise "Error occurred while accessing '#{@password_dir}': #{err}"
    end
    names.sort
  end

  def self.get_password_dir
    password_env_dir = File.join(`puppet config print vardir --section master`.strip, 'simp', 'environments')
    File.join(password_env_dir, @environment, 'simp_autofiles', 'gen_passwd')
  end

  def self.validate_names
    names = get_names
    @names.each do |name|
      unless names.include?(name)
        #FIXME print out names nicely (e.g., max 8 per line)
        raise OptionParser::ParseError.new("Invalid name '#{name}' selected.\n\nValid names: #{names.join(', ')}")
      end
    end
  end

  def self.validate_password_dir
    raise "Password directory '#{@password_dir}' does not exist" unless File.exist?(@password_dir)
    raise "Password directory '#{@password_dir}' is not a directory" unless File.directory?(@password_dir)
  end

  def self.show_environment_list
    # FIXME This ASSUMES @password_dir follows a known pattern of
    #   <env dir>/<env>/simp_autofiles/gen_passwd
    # (which also assumes Linux path separators)
    unless @password_dir.include?("/simp_autofiles/gen_passwd")
      raise "Password environment directory could not be determined from '#{@password_dir}'"
    end
    env_dir = File.dirname(@password_dir.split("/simp_autofiles/")[0])
    raise "Password environment directory '#{env_dir}' does not exist" unless File.exist?(env_dir)
    raise "Password environment directory '#{env_dir}' is not a directory" unless File.directory?(env_dir)
    environments = []
    begin
      Dir.chdir(env_dir) do
        environments = Dir.glob('*').sort
      end
    rescue SystemCallError => err
      raise "Error occurred while accessing '#{env_dir}': #{err}"
    end
    puts "Environments:\n\t#{environments.join("\n\t")}"
    puts
  end

  def self.show_name_list
    validate_password_dir
    names = get_names
    puts "#{@environment} Names:\n\t#{names.join("\n\t")}"
    puts
  end

  def self.show_passwords
    validate_password_dir
    validate_names

    title =  "#{@environment} Environment"
    puts title
    puts '='*title.length
    @names.each do |name|
      Dir.chdir(@password_dir) do
        puts "Name: #{name}"
        current_password = File.open("#{@password_dir}/#{name}", 'r').gets
        puts "  Current:  #{current_password}"
        last_password = nil
        last_password_file = "#{@password_dir}/#{name}.last"
        if File.exists?(last_password_file)
          last_password = File.open(last_password_file, 'r').gets
        end
        puts "  Previous: #{last_password}" if last_password
      end
      puts
    end
  end

  def self.set_passwords
    validate_password_dir
    @names.each do |name|
      next if name.strip.empty?
      password_filename = "#{@password_dir}/#{name}"

      puts "#{@environment} Name: #{name}"
#TODO add an auto-generate option and use Simp::Cli::Config::Utils.generate_password
      password = Utils.get_password
      if File.exists?(password_filename)
        backup_passwords = @backup_passwords
        if backup_passwords.nil?
          backup_passwords = Utils.yes_or_no("Would you like to rotate the old password?", false)
        end
        if backup_passwords
          begin
            FileUtils.mv(password_filename, password_filename + '.last', :verbose => true, :force => true)
          rescue SystemCallError => err
            raise "Error occurred while moving '#{password_filename}' to '#{password_filename + '.last'}': #{err}"
          end
        end
      end
      begin
        File.open(password_filename, 'w') { |file| file.puts password }

        # Ensure that the ownership and permissions are correct
        puppet_user = `puppet config print user`.strip
        puppet_group = `puppet config print group`.strip
        if puppet_user.empty? or puppet_group.empty?
          raise 'Could not set password file ownership:  unable to determine puppet user and group'
        end
        FileUtils.chown(puppet_user, puppet_group, password_filename)
        FileUtils.chmod(0640, password_filename)
      rescue ArgumentError => err
        # This will happen if group does not exist
        raise "Could not set password file ownership: #{err}"
      rescue SystemCallError => err
        raise "Error occurred while writing '#{password_filename}': #{err}"
      end
      puts
    end
  end

  def self.remove_passwords
    validate_password_dir
    validate_names

    @names.each do |name|
      password_filename = "#{@password_dir}/#{name}"
      if File.exists?(password_filename)
        remove = @force_remove
        unless remove
          remove = Utils.yes_or_no("Are you sure you want to remove all entries for #{name}?", false)
        end
        if remove
          last_password_filename = password_filename + '.last'
          if File.exists?(last_password_filename)
            File.delete(last_password_filename)
            puts "#{last_password_filename} deleted"
          end

          File.delete(password_filename)
          puts "#{password_filename} deleted"
        end
      end
      puts
    end
  end

  # Resets options to original values.
  # This ugly method is needed for unit-testing, in which multiple occurrences of
  # the self.run method are called with different options.
  # FIXME Variables set here are really class variables, not instance variables.
  def self.reset_options
    @operation = nil
    @environment = nil
    @password_dir = nil
    @names = Array.new
    @backup_passwords = nil
    @force_remove = false
  end
end
